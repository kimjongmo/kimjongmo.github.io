---
layout: post
title:  이펙티브자바-객체 생성과 파괴
data: 2021-02-22 21:01:00
categories: java
permalink: /java/effective-java/chapter2
tags: java effective-java
author: kimjongmo

---



## 아이템 01: 생성자 대신 정적 팩터리 메서드를 고려하라.

클래스의 인스턴스를 얻는 방법 2가지

1. public 생성자를 이용하여 직접 인스턴스 생성
2. 정적 팩터리 메서드를 이용한 인스턴스 생성



### 정적 팩터리 메서드 장/단점

#### 장점 1: 이름을 가질 수 있다.

생성자에 넘기는 매개변수만으로는 해당 생성자가 반환할 객체의 특성을 제대로 설명하지 못한다. 예를 들면 학생증을 생성한다 가정해보자.

```java
// 일반 생성자 이용
Card card = new Card(id, name, major);

// 정적 팩터리 메서드 이용
Card card = Card.student(id, name, major);
```

이름을 가질 수 있기 때문에 부가적인 정보를 얻을 수 있다. **한 클래스에 시그니처가 같은 생성자가 여러 개 필요할 것 같다면 정적 팩터리 메서드로 바꾸고 각각의 차이를 잘 드러내도록 이름을 지어주자.**

#### 장점 2 : 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.

인스턴스를 미리 만들어 놓거나, 생성된 인스턴스를 캐싱하여 재활용함으로써 불필요한 객체 생성을 피할 수 있다. 특히 **생성 비용이 큰 객체의 경우에는 더욱 효과를 발휘할 수 있다**. 

#### 장점 3 : 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.  

반환 타입의 하위 타입이 있다면 정적 팩터리 메서드를 이용하여 해당하는 **구현 클래스를 공개하지 않으면서도 원하는 타입의 하위 타입의 클래스를 자유롭게 가져올 수 있다**. 예를들면 자바의 컬렉션 프레임워크는 수정 불가나 동기화 등의 기능을 덧붙인 45개의 구현체를 공개하지 않고 Collectors를 이용하여 생성할 수 있도록 설계했는데 이 때문에 API 외견을 더 심플하게 만들 수 있었다. 

#### 장점 4 : 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

위의 하위 타입 객체를 반환할 수 있게 되면서 **전달받은 매개변수를 읽고 알맞은 하위타입을 리턴할 수 있게되었다.** 

#### 장점 5 : 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.



#### 단점 1 : 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.

**상속을 하려면 public이나 protected같은 생성자가 필요**한데 이러한 생성자 없이 오로지 정적 펙터리 메서드만 제공한다면 상속을 통해 하위 타입을 만들 수 없다.

#### 단점 2 : 정적 펙터리 메서드는 프로그래머가 찾기 어렵다.

자바독에 **정적 펙터리 메서드에 대한 설명이 명확하지 않기 때문에 사용자가 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야 한다**. 이러한 단점을 보완하기 위한 방법으로 API 문서를 잘 작성해놓거나 널리 알려진 정적 팩터리 메서드 이름을 따라 짓는 방법이 있다.

```java
// from : 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
Date d = Date.from(xxx);

// of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);

// instance, getInstance : 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다.

// create, newInstance : instance, getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
Array.newInstance(classObject, arrayLen);

// getXXX , newXXX: getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.
FileStore fs = Files.getFileStore(path);


```



> 정적 팩터리 메서드의 장점을 잘 이해하고 무조건 생성자를 만들어 사용하는 습관을 고쳐야 한다.



## 아이템 02 생성자에 매개변수가 많다면 빌더를 고려하라.

정적 팩터리, public 생성자는 선택적 매개변수가 많을 때 굉장히 복잡해진다. 기존에는 이러한 선택적 매개변수가 많을 때는 점층적 생성자 패턴을 사용해왔다.



### 점층적 생성자 패턴

```java
public Member(Long id, String name, int age, Sex sex, boolean isMembership, ....) {...}
public Member(Long id, int age, Sex sex, boolean isMembership, ....) { this(id, "", sex, isMemeberShip..)}
public Member(Long id, String name, int age, boolean isMembership, ....) { this(id, name, age, Sex.01, is..)}
public Member(Long id, boolean isMembership, ....) {...}
```

이렇게 다양한 매개변수가 존재하는 생성자를 사용하는 것은 많은 불편함이 있다.

- 생성자를 계속 추가해주어야 한다

- 생성자를 사용할 때 정확한 매개변수의 순서를 알아야한다.

- 코드리뷰가 어렵다

    ```java
    new Order("살코기",100,2,3000,2,"옵션1");  // ?????
    ```

- 리팩토링이 힘들다

    ```java
    // 예를들면 매개변수의 위치를 바꾼다고 하였을 때
    // public Member(String name, String nickname) {} -> public Member(String nickname, String name) {}
    public Member(String nickname, String name) {
    	this.name = name;
      this.nickname = nickname;
    } 
    
    //  
    Member member = new Member("홍길동","닉네임"); // 오류가 나지 않고 정상적인 문법으로 보기 때문에 쉽게 알아채기 힘들다.
    ```

    

### 자바빈즈 패턴

매개변수가 없는 생성자로 객체를 만들고 세터 메서드들을 호출하여 매개변수를 세팅하는 방식이다.

```java
public class Order {
  private int id;
  private String name;
  private int price;
  private int calories;

  public void setId(int id){this.id = id;}
  public void setName(String name){this.name = name;}
	...
}

{
  Order order = new Order();
  order.setId(1);
  order.setName("주문1");
  ..
}
```

위와 같은 자바빈즈 패턴으로 위의 문제들을 해결할 수 있다. 다만 이 패턴에도 문제가 있는데 다음과 같다

- 코드가 길어졌다.

- 객체 하나를 만들기 위해 메서드를 여러 개 호출해야 한다.

- 객체가 생성되기 전까지는 일관성이 없을 수 있다. 

- 멀티 스레드 환경에서 계속 값이 변할 수 있다(=불변 객체다)

    어떤 스레드에서 어떤 값을 변경시켜놓을지 알수 없어 부가적인 기능(싱크로나이즈)들도 필요할 수 있다.



### 빌더 패턴

클래스를 만들기 위한 빌더를 만들고 빌더가 제공하는 세터 메서드들을 체이닝 형식으로 호출하여 원하는 인스턴스를 생성할 수 있다,

```java
public class Order {
  private int id;
  private String name;
  private int price;
  private int calories;

  public static class OrderBuilder {
    private int id;
    private String name;
    private int price;
    private int calories;
    
    public OrderBuilder id(int id) {this.id = id;}
    public OrderBuilder name(String name) {this.name = name;}
   	...
    public Order build() {
      Order order = new Order();
      order.id = id;
      ...
    }  
  }
}

{
  Order order = Order.OrderBuilder().id(1).name("주문1").price(1000).build();
}
```

- Lombok 프로젝트의 @Builder 패턴은 이러한 수고를 덜어줄 수 있다.



## 아이템 03 private 생성자나 열거 타입으로 싱글턴임을 보증하라

싱글턴 : 오직 인스턴스를 하나만 생성할 수 있는 클래스

클래스를 싱글턴으로 만듦으로 무상태 객체나 설계상 유일해야 하는 시스템 컴포넌트로 만든다.



### 싱글턴 만드는 방법 1

private 생성자를 만들고, static 필드를 이용해 접근하게 만든다.

```java
// 방법 1
public class Singleton {
    public static final Singleton singleton = new Singleton();
    
    private Singleton() { ... } 
    
    
}
```

위의 예시 코드의 경우를 봤을 때는 private 생성자는 Singleton 클래스가 초기화될 때 딱한번 호출될거라 생각된다. 하지만 리플렉션 API를 사용한다면 private 생성자는 다시 호출 가능하다. 따라서 위와같은 방식으로 싱글턴을 만들고자 한다면 생성자 내부에 두 번째 객체가 생성되려 할 때 예외를 던지도록 수정을 해야 한다. 

또한 해당 클래스가 직렬화가 가능하다면 이것또한 또 다른 인스턴스를 만들게 될 수도 있다. 따라서 모든 인스턴스 필드를 transient라 선언하고 readResolve 와 같은 메서드를 제공해야 한다.

```java
private Singleton() {
  if(Singleton.singleton != null) {
    throw IllegalAccessException("this class shoud be singleton");
  }
}
```

### 싱글턴 만드는 방법 2

정적 팩터리 메서드를 static 으로 만들어 제공한다.

```java
public class Singleton {
  private static final Singleton instance = new Singleton();
  private Singleton(){...}
  public static Singleton getInstance() { return instance; }
}
```

위의 예제 또한 1번 방법과 같이 리플렉션 및 직렬화에 취약하다. 다만 위의 방법이 가져올 수 있는 장점은 다음과 같다

- API를 바꾸지 않고도 싱글턴이 아니게 변경 할 수 있다
- 원한다면 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다
- 정적 팩터리의 메서드 참조를 공급자로 사용할 수 있다

라고 책에는 써있다만 이게 도통 무슨말인지 잘 모르겠다..

### 싱글턴을 만드는 방법 3

```java
public enum Singleton {
  INSTANCE;
  
  private Singleton(){}
}
```

위의 방법은 리플렉션 및 직렬화에서도 또 다른 인스턴스가 생기지 않도록 막아준다.



## 아이템 04 인스턴스화를 막으려거든 private 생성자를 사용하라

정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 것이 아니다. 하지만 이러한 클래스들은 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 생성해놓는다. 이처럼 의도치 않게 인스턴스화할 수 있게 된 클래스가 종종 목격된다. 

그러면 abstract class를 이용해서 인스턴스화 하는걸 막을 수 있지 않을까?? 이러한 생각도 아쉽게도 인스턴스화를 막을 수 있는 방법은 아니다. 왜냐하면 해당 추상클래스를 상속받아 정의하는 하위클래스를 만들어 인스턴스화할 수 있기 때문이다. 또한 abstract class를 보면 왠지 모르게 하위 클래스를  만들어서 쓰라고 하는 것 같아보이니 더 큰 문제다. 

결론적으로는 이러한 생성자를 인스턴스화 하는걸 막기위해서는 private 생성자를 선언해주어야 한다. 이렇게 한다면 컴파일러가 생성자가 있으니 자동으로 생성자를 추가해놓지도, 이를 상속받아서 사용할수도, 직접 생성해서 사용할수도 없기 때문이다. 

또한 private 생성자 내부에 호출이 되면 에러를 내뱉도록 추가해주어도 좋을것이다. 왜냐하면 리플렉션이나 직렬화도중에 생성이 될수도 있으니까..

한가지 유의하면 좋을 점은 이러한 private 생성자는 개발자가 볼때 직관적이게 보일수가 없다. 왜냐하면 생성자를 만들어놓고 사용하지 못하게 private으로 선언해놓다니 이게 뭔가 ?? 할수도 있기 때문이다. 따라서 이와 같은 코드에는 적절한 주석을 추가해 주는게 좋다.



## 아이템 05 자원을 직접 명시하지 말고  의존 객체 주입을 사용하라

#### 클래스에서 외부의 클래스에 의존

프로그래밍을 하다보면 한 클래스 내부에서 다른 클래스들을 사용하는 모습을 보게 된다. 예시로 맞춤법 검사기를 들어보겠다. 아래의 예시에서 맞춤법 검사기는 한글 사전에 의존을 하고 있는걸 볼 수 있다. 뒤의 설명을 위해 일단 정적 유틸리티 클래스로 구현한 모습과 싱글턴으로 구현한 모습을 예시로 들겠다.

```java
// 정적 유틸리티 클래스
class SpellChecker {
    private static final Dictionary dict = new KoreanDictionary; // 자신이 아닌 외부의 클래스 의존.
    
    private SpellChecker(){}
    
    public static boolean isValid(String word){...}
}

// 싱글턴 
class SpeelChecker {
    private final Dictionary dict = new KoreanDictionary;
    
	private static SpellChecker INSTANCE = new SpellChecker();
    
    public boolean isValid(String word) {...}
    
    public SpellChecker getInstance(){
        return INSTANCE;
    }

}
```



#### 자원에 따라 비슷하지만 여러 개 생성되는 클래스가 존재

위의 예시로는 한국어 사전을 지원하는 맞춤법 검사기를 만들었지만 만약 여기에 다른 외국어 사전들이 지원되어야 한다고 생각하면 아래의 작업들이 공통적으로 되어야 한다.

1) 필드에 붙은 final 한정자 제거

2) 사전 교체 메서드 추가

```java
class KoreanDictionary extends Dictionary {  // 한국어 사전
	
}
class EnglishDictionary extends Dictionary { // 영어 사전
    
}

// 사용 유틸 클래스 
class SpellChecker {
    private static final Dictionary dict = new KoreanDictionary; // 자신이 아닌 외부의 클래스 의존.
    
    private SpellChecker(){}
    
    public static boolean isValid(String word){...}
    
    public void convertTo(Dictionary dict) { // 사전 교체
        this.dict = dict;
    }
}
// thread1
{
    KoreanDictionary koDict = new KoreanDictionary();
    SpellChecker.convertTo(koDict);  // 12시 30분 1초
    SpellChecker.isValid("만듦"); // 12시 30분 3초 , 아래의 스레드에서 SpellChecker의 사전을 영어로 세팅해버린 상태.
}

// thread2
{
    EnglishDictionary enDict = new EnglishDictionary();
    SpellChecker.convertTo(enDict); // 12시 30분 2초
    SpellChecker.isValid("applle"); 
}
```

위의 예제에서 볼 수 있듯이 <u>이 방식은 어색하면서도 오류를 내기 쉬우며 특히 멀티 스레드 환경에서는 굉장히 취약할 수 있다</u>. 따라서 위오 같이 **사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱클턴 방식이 적합하지 않다**. 



#### 의존 주입 패턴

클래스는 여러 자원의 인스턴스를 지원해야 하며, 클라이언트가 원하는 자원을 사용할 수 있어야 한다. 이러한 점들을 만족시켜줄 수 있는 패턴이 있는데 그것은 바로 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식이다. 

```java
// 사용 유틸 클래스 
class SpellChecker {
    private Dictionary dict = new KoreanDictionary; // default: 한국어 사전 
    
    public SpellChecker(Dictionary dict) {
        this.dict = dict;
    }
}

// thread1
{
    SpellChecker checker = new SpellChecker(new KoreanDictionary);
    checker.isValid("만듦"); 
}

// thread2
{
    SpellChecker checker = new SpellChecker(new EnglishDictionary);
    checker.isValid("applle"); 
}
```

이처럼 의존 객체 주입 패턴을 이용하면 자원이 몇 개든 의존 관계가 어떻든 상관없이 잘 장독하며, 불편을 보장하고, 여러 클라이언트가 의존 객체들을 안심하고 공유할 수 있기도 하다. (클래스의 유연성, 재사용성, 테스트 용이성 증가!!) 

다만 의존성이 수 천 개나 되는 큰 프로젝트에서는 코드를 어지럽게 만들 수 있는데 스프링과 같은 의존 객체 주입 프레임워크를 사용하면 이런 어질러짐을 해소할 수 있다. 

## 아이템 06 불필요한 객체 생성을 피하라

 같은 기능을 지닌 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다. 특히 불변 객체는 언제든 재사용할 수 있다. 다만 이렇게 사용을 할 때에는 주의해야 하는 부분들이 있다.

###  문자열 생성

`new String("Y")` 이 있다. 이 코드는 매 실행때마다 새로운 String 인스턴스를 만들어낸다. 이 코드는 그냥 `="Y"`로 만들어  저장하는 것과 기능적으로 다르지 않으나 만약 반복문 등에서 호출이 된다면 호출될 때마다 새로운 인스턴스를 생성해야 하니 비효율적이다.



### 정적 팩터리 메서드

정적 팩터리 메서드를 이용하여 불필요한 객체 생성을 피할 수 있다. 예컨대 싱글톤의 getInstance 메서드를 생각해보자 애플리케이션이 시작되면서 생성된 객체를 계속 넘겨주기만 하면 되니까 불필요한 객체의 생성을 막을 수 있다. 

유틸클래스를 생각해볼 수도 있다. 패스워드에 영어, 숫자가 들어있는지 검사하는 로직을 아래처럼 만들었다 가정해보자.

```java
abstract class PasswordChecker {
    public static boolean isAvailable(Stirng password) {
        return password.matches("^(?=.*[0-9])(?=.*[a-z])(?=/*[A-Z]).{8,10}");
    }
}
```

이 유틸클래스의 메서드는 실행할 때 matches가 내부적으로 패턴 객체를 만들어 쓰는데 그 패턴 객체를 만들려면 정규표현식으로 유한 상태 기계로 컴파일 하는 과정이 필요하다. 따라서 이 패턴을 미리 패턴객체로 만들어두면 성능적으로 이득을 볼 수 있다.

```java
abstract class PasswordChecker {
    
    private static final Pattern pattern = Pattern.complile("^(?=.*[0-9])(?=.*[a-z])(?=/*[A-Z]).{8,10}");
    
    public static boolean isAvailable(Stirng password) {
        return password.matches(pattern);
    }
}
```

 

### 어댑터

 어댑터는 뷰라고도 불리며, 실제 작업은 뒷단 객체에 위임하고, 자신은 제2의 인터페이스 역할을 해주는 객체이다. 즉 뒷단 객체 외에는 관리할 상태가 없으므로 뒷단 객체 하나당 어댑터 하나씩만 만들어지면 충분하다.

예를 들면 Map 컬렉션의 keySet 메서드가 있는데 이 메서드를 매번 호출할 떄마다 새로운 Set 인스턴스가 만들어질거라 기대할 수 있지만 실상 같은 Set 인스턴스를 반환하고 있다. 여기서 Set 은 Map 에 대한 인터페이스 역할이므로 굳이 매번 다른 객체를 준다하더라도 특별한 이득이 없다.



### 오토박싱

오토박싱은 프리미티브 타입과 박스 타입의 경계가 안보이게 해주지만 그렇다고 경계를 없애주는 것이 아니다.

```java
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i<= Integer.MAX_VALUE; i++) 
        sum += i;
    return sum;
}
```

위으 코드에서 sum 변수를 Long 으로 선언하게 됨으로써 `sum += i` 를 수행하게 될 때 Long 인스턴스로 만들어야 하는데 아마 `Long 메모리 * 2^31` 만큼 메모리 및 인스턴스가 생성될 것이다. 



## 다 쓴 객체 참조를 해제하라

자바의 편의성 중 하나는 C, C++과 같은 프로그래밍 언어처럼 메모리를 직접 관리하는 것이 아니라 가비지 컬렉터를 이용해 메모리를 자동으로 비우는 것이다. 메모리를 자동으로 관리해준다 하여 더 이상 신경쓰지 않아도 된다는 말은 아니다. 간단한 스택 코드를 예를 들 수 있다,



### 스택

```java
public class Stack {
  private Object[] elements;
  private int size = 0;
  private static final int capacity = 16;
  
  public Stack(){
    elements = new Object[capacity];
  }
  
  public void push(Object e){
    ensureCapacity();
    elements[size++] = e;
  }
  
  public Object pop(){
    if(size == 0) throw new EmptyStackException();
    return elements[--size];
  }
  
  private void ensureCapacity(){
    if(elements.length == size) {
      elements = Arrays.copyOf(elements, 2 * size + 1);
    }
  }
}
```

위와 같은 코드로 프로그램이 오래 실행하다보면 가비지 컬렉션 활동과 메모리 사용량이 늘어나 결국 성능이 저하된다. 이 코드가 메모리 누수가 될 수 있는 경우는 스택이 커졌다가 줄어들었을 때 스택에서 꺼내진 객체들을 가비지 컬렉터가 회수 하지 않기 때문이다. 스택이 pop 되었다하지만 실제로는 해당 인덱스에 쓰지않는 객체를 남겨둔채로 냅두었기 때문에 가비지 컬렉터가 이 객체가 앞으로 사용하지 않는다는 것을 알아내지 못한다. 위의 코드에서 메모리 누수를 막기위한 코드는 간단한데 스택에서 꺼낼때 해당 객체를 null로 세팅해버리면 된다.

```java
public Object pop(){
  if(size == 0) throw new EmptyStackException();
  elements[size] = null; // 다 쓴 참조 해제
  return elements[--size];
}
```

Stack 클래스는 특히 메모리 누수에 취약한데 스택은 객체 자체가 아닌 객체의 참조를 담아내기 때문에 가비지 컬렉터입장에서는 이 객체를 참조하는 곳(스택)이 있으니 당연히 해당 객체를 해제 대상으로 보지 않아버리기 때문이다. 때문에 스택 클래스를 사용을 할 때에는 위와 같이 쓰지 않는 객체를 해제하는 것이 필요하다.



### 캐시

캐시 역시 메모리 누수를 일으키는 주범이다. 객체 참조를 캐시에 넣고 난 후 한팜을 그냥 놔두는 일을 자주 접한다. 이에 대한 해법으로는 WeakHashMap을 사용하는 것이다. 이는 캐시 외부에서 키를 참조하는 동안에만 저장되고 다 쓴 엔트리는 그 즉시 자동으로 제거가 될 것이다. 

캐시를 만들 때 보통은 캐시 엔트리의 유효 기간을 정확히 정의하기 어렵기 때문에 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식을 흔히 사용한다. 이런 방식에서는 쓰지 않는 엔트리를 이따금 청소해줘야 하며 대게 백그라운드 스레드를 활용하거나 캐시에 새 엔트리를 추가할 때 부수 작업으로 청소해주어야 한다. 



### 리스너, 콜백

클라이언트가 콜백을 등록만 하고 명확히 해제하지 않을 때, 특별한 조치가 없다면 콜백은 계속 쌓여만 갈것이다. 이럴 때 콜백을 약한 참조로 저장하면 가비지 컬렉터가 즉시 수거해간다. 위의 얘기가 나왔던 WeakHashMap을 사용한다면 된다.



## 아이템 08: finalizer와 cleaner 사용을 피하라

finalizer와 cleaner는 자바에서 객체를 소멸시키기 위해 사용된다. finalizer는 에측할 수 없고, 상황에 따라 위험할 수 있고, 오동작, 낮은 성능, 이식성 문제의 원인이 되기도 하여 자바 9에서부터는 deprecated 로 지정하고 cleaner를 대안으로 내놓았지만 이 역시 finalizer에 비해 덜 위험할 뿐 여전히 예측불가능하며, 느리고, 불필요하다.

### 시점과 수행 여부를 예측할 수 없다

**Finalizer, cleaner는 가비지 컬렉터 알고리즘에 달렸으며, 가비지 컬렉터 구현마다 천차만별이기 때문에 실행되기 까지 얼마나 걸릴지 알 수 없다.** 

- 파일 닫기를 이들에게 맡기게 된다면 중대한 오류가 발생할 수 있다. 시스템이 동시에 열 수 있는 파일 개수가 한계가 있는데 만약 이 finalizer, cleaner가 우리가 생각하는 타이밍보다 훨씬 늦게 이를 닫음으로써 파일을 열지 못한다면 프로그램이 실패할 수 있다.
- 인스턴스의 자원 회수를 맡기게 된다면 finalizer 스레드는 다른 스레드보다 우선 순위가 낮아서 실행될 기회를 못 얻고 계속 메모리에 머물게 됨으로써 OutOfMemoryError를 낼 수 있다.
    - Cleaner 스레드는 자신을 수행할 스레드를 제어할 수 있다는 면에서 조금 낫지만 여전히 언제 실행될 지 예측할 수 없다.
- 접근할 수 없는 일부 객체에 딸린 종료 작업을 전혀 수행하지 못한 채 프로그램이 중단될 수도 있다. 프로그램 생애주기와 상관없는, 상태를 영구적으로 수정하는 작업에서 finalizer, cleaner는 사용하면 안된다. 데이터베이스 같은 공유 자원의 영구 락 해제를 이들에게 맡겨 놓으면 분산 시스템 전체가 서서히 멈추게 된다.

- Finalizer 스레드의 경우 동작 중 발생한 예외는 무시되며, 처리할 작업이 남았더라도 그 순간 종료된다. 잡지 못한 예외 대문에 때문에 해당 객체가 자칫 마무리 되지 못하고 남는 상태가 될 수 있다. 또한 보통의 경우 잡지 못한 예외가 일어나면 스레드를 중단시키고 스택 추적 내역을 출력하지만 finalizer 스레드는 무시한다.

### 성능의 문제 

finalizer, cleaner는 가비지 컬렉터의 효율을 떨어뜨린다. 책에 나와있는 저자의 실험 기준으로는 AutoCloseable 객체를 생성하고 가비지 컬렉터가 수거하기가지 12ns 정도가 걸렸고 finalizer가 50배인 550ns, cleaner가 66ns 정도 나왔다고 한다.



### finalizer 공격

Finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다. 생성자나 직렬화 과정에서 예외가 발생하면, 이 생성되다 만 객체에서 악의적인 하위 클래스의 finalizer가 수행될 수 있게 된다. 
참고 : https://self-learning-java-tutorial.blogspot.com/2020/03/finalizer-attack-in-java.html

이러한 공격을 막기위해서는 위의 글에서 나온 것처럼 하는 방법이 있다.

1. final class로 만든다
2. finalize 메소드를 오버라이딩 하지 못하게 final키워드를 붙인다



### 그럼 cleaner, finalizer 도대체 언제쓰라는거야?

1. 자원의 소유자가 close 메서드를 호출하지 않는 것에 대비한 안정망 역할
2. 네이티브 객체를 회수





## try-finally 보다는 try-with-resources를 사용하라

자바에서는 InputStream, OutputStream, Connection 등 close 메서드를 직접 호출해주어야 하는 자원들이 있다. 대체적으로 close 메서드를 닫아주기 위해 아래와 같은 코드를 많이 사용할 것이다.

```java
BufferedReader br = new BufferedReader(new FileReader(path));
try {
  return br.readLine();
} finally {
  br.close();
}
```

위의 코드역시 좋은 코드이지만 자원을 하나 더 사용한다고 가정해보자. 그러면 아래와 같이 하면 될라나?

```java
BufferedReader br = new BufferedReader(new FileReader(inPath));
try {
  String line = br.readLine();
  BufferedWriter bw = new BufferedWriter(new FileWriter(outPath));
  try {
    bw.write(line);
    bw.flush();
  } finally {
    bw.close();
  }
} finally {
  br.close();
}
```

코드가 굉장히 지저분해졌다는 걸 알수있다. 

### try-with-resources

try-with-resources 를 사용하기 위해서는 해당 자원이 AutoCloseable 인터페이스를 구현해야 한다. 일단 try-with-resource를 적용해보자

```java
try(
  BufferedReader br = new BufferedReader(new FileReader(path));
  BufferedWriter bw = new BufferedWriter(new FileWriter(path));  
) {
  String line = br.readLine();
  bw.write(line);
  bw.flush();
}
```

try-finally 구조보다 훨씬 간결하고 개발자가 실수로라도 놓칠 수 있는 부분들을 방지할 수 있다.