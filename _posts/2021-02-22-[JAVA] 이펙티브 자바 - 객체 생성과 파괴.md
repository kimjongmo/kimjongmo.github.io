---
layout: post
title:  이펙티브자바-객체 생성과 파괴
data: 2021-02-22 21:01:00
categories: java
permalink: /java/effective-java/chapter2
tags: java effective-java
author: kimjongmo

---



## 아이템 01: 생성자 대신 정적 팩터리 메서드를 고려하라.

클래스의 인스턴스를 얻는 방법 2가지

1. public 생성자를 이용하여 직접 인스턴스 생성
2. 정적 팩터리 메서드를 이용한 인스턴스 생성



### 정적 팩터리 메서드 장/단점

#### 장점 1: 이름을 가질 수 있다.

생성자에 넘기는 매개변수만으로는 해당 생성자가 반환할 객체의 특성을 제대로 설명하지 못한다. 예를 들면 학생증을 생성한다 가정해보자.

```java
// 일반 생성자 이용
Card card = new Card(id, name, major);

// 정적 팩터리 메서드 이용
Card card = Card.student(id, name, major);
```

이름을 가질 수 있기 때문에 부가적인 정보를 얻을 수 있다. **한 클래스에 시그니처가 같은 생성자가 여러 개 필요할 것 같다면 정적 팩터리 메서드로 바꾸고 각각의 차이를 잘 드러내도록 이름을 지어주자.**

#### 장점 2 : 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.

인스턴스를 미리 만들어 놓거나, 생성된 인스턴스를 캐싱하여 재활용함으로써 불필요한 객체 생성을 피할 수 있다. 특히 **생성 비용이 큰 객체의 경우에는 더욱 효과를 발휘할 수 있다**. 

#### 장점 3 : 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.  

반환 타입의 하위 타입이 있다면 정적 팩터리 메서드를 이용하여 해당하는 **구현 클래스를 공개하지 않으면서도 원하는 타입의 하위 타입의 클래스를 자유롭게 가져올 수 있다**. 예를들면 자바의 컬렉션 프레임워크는 수정 불가나 동기화 등의 기능을 덧붙인 45개의 구현체를 공개하지 않고 Collectors를 이용하여 생성할 수 있도록 설계했는데 이 때문에 API 외견을 더 심플하게 만들 수 있었다. 

#### 장점 4 : 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

위의 하위 타입 객체를 반환할 수 있게 되면서 **전달받은 매개변수를 읽고 알맞은 하위타입을 리턴할 수 있게되었다.** 

#### 장점 5 : 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.



#### 단점 1 : 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.

**상속을 하려면 public이나 protected같은 생성자가 필요**한데 이러한 생성자 없이 오로지 정적 펙터리 메서드만 제공한다면 상속을 통해 하위 타입을 만들 수 없다.

#### 단점 2 : 정적 펙터리 메서드는 프로그래머가 찾기 어렵다.

자바독에 **정적 펙터리 메서드에 대한 설명이 명확하지 않기 때문에 사용자가 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야 한다**. 이러한 단점을 보완하기 위한 방법으로 API 문서를 잘 작성해놓거나 널리 알려진 정적 팩터리 메서드 이름을 따라 짓는 방법이 있다.

```java
// from : 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
Date d = Date.from(xxx);

// of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);

// instance, getInstance : 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다.

// create, newInstance : instance, getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
Array.newInstance(classObject, arrayLen);

// getXXX , newXXX: getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.
FileStore fs = Files.getFileStore(path);


```



> 정적 팩터리 메서드의 장점을 잘 이해하고 무조건 생성자를 만들어 사용하는 습관을 고쳐야 한다.



## 아이템 02 생성자에 매개변수가 많다면 빌더를 고려하라.

정적 팩터리, public 생성자는 선택적 매개변수가 많을 때 굉장히 복잡해진다. 기존에는 이러한 선택적 매개변수가 많을 때는 점층적 생성자 패턴을 사용해왔다.



### 점층적 생성자 패턴

```java
public Member(Long id, String name, int age, Sex sex, boolean isMembership, ....) {...}
public Member(Long id, int age, Sex sex, boolean isMembership, ....) { this(id, "", sex, isMemeberShip..)}
public Member(Long id, String name, int age, boolean isMembership, ....) { this(id, name, age, Sex.01, is..)}
public Member(Long id, boolean isMembership, ....) {...}
```

이렇게 다양한 매개변수가 존재하는 생성자를 사용하는 것은 많은 불편함이 있다.

- 생성자를 계속 추가해주어야 한다

- 생성자를 사용할 때 정확한 매개변수의 순서를 알아야한다.

- 코드리뷰가 어렵다

    ```java
    new Order("살코기",100,2,3000,2,"옵션1");  // ?????
    ```

- 리팩토링이 힘들다

    ```java
    // 예를들면 매개변수의 위치를 바꾼다고 하였을 때
    // public Member(String name, String nickname) {} -> public Member(String nickname, String name) {}
    public Member(String nickname, String name) {
    	this.name = name;
      this.nickname = nickname;
    } 
    
    //  
    Member member = new Member("홍길동","닉네임"); // 오류가 나지 않고 정상적인 문법으로 보기 때문에 쉽게 알아채기 힘들다.
    ```

    

### 자바빈즈 패턴

매개변수가 없는 생성자로 객체를 만들고 세터 메서드들을 호출하여 매개변수를 세팅하는 방식이다.

```java
public class Order {
  private int id;
  private String name;
  private int price;
  private int calories;

  public void setId(int id){this.id = id;}
  public void setName(String name){this.name = name;}
	...
}

{
  Order order = new Order();
  order.setId(1);
  order.setName("주문1");
  ..
}
```

위와 같은 자바빈즈 패턴으로 위의 문제들을 해결할 수 있다. 다만 이 패턴에도 문제가 있는데 다음과 같다

- 코드가 길어졌다.

- 객체 하나를 만들기 위해 메서드를 여러 개 호출해야 한다.

- 객체가 생성되기 전까지는 일관성이 없을 수 있다. 

- 멀티 스레드 환경에서 계속 값이 변할 수 있다(=불변 객체다)

    어떤 스레드에서 어떤 값을 변경시켜놓을지 알수 없어 부가적인 기능(싱크로나이즈)들도 필요할 수 있다.



### 빌더 패턴

클래스를 만들기 위한 빌더를 만들고 빌더가 제공하는 세터 메서드들을 체이닝 형식으로 호출하여 원하는 인스턴스를 생성할 수 있다,

```java
public class Order {
  private int id;
  private String name;
  private int price;
  private int calories;

  public static class OrderBuilder {
    private int id;
    private String name;
    private int price;
    private int calories;
    
    public OrderBuilder id(int id) {this.id = id;}
    public OrderBuilder name(String name) {this.name = name;}
   	...
    public Order build() {
      Order order = new Order();
      order.id = id;
      ...
    }  
  }
}

{
  Order order = Order.OrderBuilder().id(1).name("주문1").price(1000).build();
}
```

- Lombok 프로젝트의 @Builder 패턴은 이러한 수고를 덜어줄 수 있다.



## private 생성자나 열거 타입으로 싱글턴임을 보증하라

싱글턴 : 오직 인스턴스를 하나만 생성할 수 있는 클래스

클래스를 싱글턴으로 만듦으로 무상태 객체나 설계상 유일해야 하는 시스템 컴포넌트로 만든다.



### 싱글턴 만드는 방법 1

private 생성자를 만들고, static 필드를 이용해 접근하게 만든다.

```java
// 방법 1
public class Singleton {
    public static final Singleton singleton = new Singleton();
    
    private Singleton() { ... } 
    
    
}
```

위의 예시 코드의 경우를 봤을 때는 private 생성자는 Singleton 클래스가 초기화될 때 딱한번 호출될거라 생각된다. 하지만 리플렉션 API를 사용한다면 private 생성자는 다시 호출 가능하다. 따라서 위와같은 방식으로 싱글턴을 만들고자 한다면 생성자 내부에 두 번째 객체가 생성되려 할 때 예외를 던지도록 수정을 해야 한다. 

또한 해당 클래스가 직렬화가 가능하다면 이것또한 또 다른 인스턴스를 만들게 될 수도 있다. 따라서 모든 인스턴스 필드를 transient라 선언하고 readResolve 와 같은 메서드를 제공해야 한다.

```java
private Singleton() {
  if(Singleton.singleton != null) {
    throw IllegalAccessException("this class shoud be singleton");
  }
}
```

### 싱글턴 만드는 방법 2

정적 팩터리 메서드를 static 으로 만들어 제공한다.

```java
public class Singleton {
  private static final Singleton instance = new Singleton();
  private Singleton(){...}
  public static Singleton getInstance() { return instance; }
}
```

위의 예제 또한 1번 방법과 같이 리플렉션 및 직렬화에 취약하다. 다만 위의 방법이 가져올 수 있는 장점은 다음과 같다

- API를 바꾸지 않고도 싱글턴이 아니게 변경 할 수 있다
- 원한다면 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다
- 정적 팩터리의 메서드 참조를 공급자로 사용할 수 있다

라고 책에는 써있다만 이게 도통 무슨말인지 잘 모르겠다..

### 싱글턴을 만드는 방법 3

```java
public enum Singleton {
  INSTANCE;
  
  private Singleton(){}
}
```

위의 방법은 리플렉션 및 직렬화에서도 또 다른 인스턴스가 생기지 않도록 막아준다.



## 인스턴스화를 막으려거든 private 생성자를 사용하라

정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 것이 아니다. 하지만 이러한 클래스들은 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 생성해놓는다. 이처럼 의도치 않게 인스턴스화할 수 있게 된 클래스가 종종 목격된다. 

그러면 abstract class를 이용해서 인스턴스화 하는걸 막을 수 있지 않을까?? 이러한 생각도 아쉽게도 인스턴스화를 막을 수 있는 방법은 아니다. 왜냐하면 해당 추상클래스를 상속받아 정의하는 하위클래스를 만들어 인스턴스화할 수 있기 때문이다. 또한 abstract class를 보면 왠지 모르게 하위 클래스를  만들어서 쓰라고 하는 것 같아보이니 더 큰 문제다. 

결론적으로는 이러한 생성자를 인스턴스화 하는걸 막기위해서는 private 생성자를 선언해주어야 한다. 이렇게 한다면 컴파일러가 생성자가 있으니 자동으로 생성자를 추가해놓지도, 이를 상속받아서 사용할수도, 직접 생성해서 사용할수도 없기 때문이다. 

또한 private 생성자 내부에 호출이 되면 에러를 내뱉도록 추가해주어도 좋을것이다. 왜냐하면 리플렉션이나 직렬화도중에 생성이 될수도 있으니까..

한가지 유의하면 좋을 점은 이러한 private 생성자는 개발자가 볼때 직관적이게 보일수가 없다. 왜냐하면 생성자를 만들어놓고 사용하지 못하게 private으로 선언해놓다니 이게 뭔가 ?? 할수도 있기 때문이다. 따라서 이와 같은 코드에는 적절한 주석을 추가해 주는게 좋다.



## 자원을 직접 명시하지 말고  의존 객체 주입을 사용하라

#### 클래스에서 외부의 클래스에 의존

프로그래밍을 하다보면 한 클래스 내부에서 다른 클래스들을 사용하는 모습을 보게 된다. 예시로 맞춤법 검사기를 들어보겠다. 아래의 예시에서 맞춤법 검사기는 한글 사전에 의존을 하고 있는걸 볼 수 있다. 뒤의 설명을 위해 일단 정적 유틸리티 클래스로 구현한 모습과 싱글턴으로 구현한 모습을 예시로 들겠다.

```java
// 정적 유틸리티 클래스
class SpellChecker {
    private static final Dictionary dict = new KoreanDictionary; // 자신이 아닌 외부의 클래스 의존.
    
    private SpellChecker(){}
    
    public static boolean isValid(String word){...}
}

// 싱글턴 
class SpeelChecker {
    private final Dictionary dict = new KoreanDictionary;
    
	private static SpellChecker INSTANCE = new SpellChecker();
    
    public boolean isValid(String word) {...}
    
    public SpellChecker getInstance(){
        return INSTANCE;
    }

}
```



#### 자원에 따라 비슷하지만 여러 개 생성되는 클래스가 존재

위의 예시로는 한국어 사전을 지원하는 맞춤법 검사기를 만들었지만 만약 여기에 다른 외국어 사전들이 지원되어야 한다고 생각하면 아래의 작업들이 공통적으로 되어야 한다.

1) 필드에 붙은 final 한정자 제거

2) 사전 교체 메서드 추가

```java
class KoreanDictionary extends Dictionary {  // 한국어 사전
	
}
class EnglishDictionary extends Dictionary { // 영어 사전
    
}

// 사용 유틸 클래스 
class SpellChecker {
    private static final Dictionary dict = new KoreanDictionary; // 자신이 아닌 외부의 클래스 의존.
    
    private SpellChecker(){}
    
    public static boolean isValid(String word){...}
    
    public void convertTo(Dictionary dict) { // 사전 교체
        this.dict = dict;
    }
}
// thread1
{
    KoreanDictionary koDict = new KoreanDictionary();
    SpellChecker.convertTo(koDict);  // 12시 30분 1초
    SpellChecker.isValid("만듦"); // 12시 30분 3초 , 아래의 스레드에서 SpellChecker의 사전을 영어로 세팅해버린 상태.
}

// thread2
{
    EnglishDictionary enDict = new EnglishDictionary();
    SpellChecker.convertTo(enDict); // 12시 30분 2초
    SpellChecker.isValid("applle"); 
}
```

위의 예제에서 볼 수 있듯이 <u>이 방식은 어색하면서도 오류를 내기 쉬우며 특히 멀티 스레드 환경에서는 굉장히 취약할 수 있다</u>. 따라서 위오 같이 **사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱클턴 방식이 적합하지 않다**. 



#### 의존 주입 패턴

클래스는 여러 자원의 인스턴스를 지원해야 하며, 클라이언트가 원하는 자원을 사용할 수 있어야 한다. 이러한 점들을 만족시켜줄 수 있는 패턴이 있는데 그것은 바로 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식이다. 

```java
// 사용 유틸 클래스 
class SpellChecker {
    private Dictionary dict = new KoreanDictionary; // default: 한국어 사전 
    
    public SpellChecker(Dictionary dict) {
        this.dict = dict;
    }
}

// thread1
{
    SpellChecker checker = new SpellChecker(new KoreanDictionary);
    checker.isValid("만듦"); 
}

// thread2
{
    SpellChecker checker = new SpellChecker(new EnglishDictionary);
    checker.isValid("applle"); 
}
```

이처럼 의존 객체 주입 패턴을 이용하면 자원이 몇 개든 의존 관계가 어떻든 상관없이 잘 장독하며, 불편을 보장하고, 여러 클라이언트가 의존 객체들을 안심하고 공유할 수 있기도 하다. (클래스의 유연성, 재사용성, 테스트 용이성 증가!!) 

다만 의존성이 수 천 개나 되는 큰 프로젝트에서는 코드를 어지럽게 만들 수 있는데 스프링과 같은 의존 객체 주입 프레임워크를 사용하면 이런 어질러짐을 해소할 수 있다. 