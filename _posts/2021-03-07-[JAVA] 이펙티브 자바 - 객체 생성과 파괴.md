layout: post
title:  이펙티브자바-객체 생성과 파괴
data: 2021-03-07 00:15:00
categories: java
permalink: /java/effective-java/chapter2
tags: java effective-java
author: kimjongmo



## 아이템 01: 생성자 대신 정적 팩터리 메서드를 고려하라.

클래스의 인스턴스를 얻는 방법은 2가지가 존재한다.

1. public 생성자를 이용하여 직접 인스턴스 생성
2. 정적 팩터리 메서드를 이용한 인스턴스 생성

정적 팩터리 메서드와 public 생성자 각자의 장단점이 있어 적절한 시기에 각각을 고려해보아야 한다.



### 명시적인 이름

생성자에 넘기는 매개변수만으로는 해당 생성자가 반환할 객체의 특성을 제대로 설명하지 못한다. 

```java
// api요청 실패 응답
public ApiResponse(String msg) {
	this.status = 400;
	this.msg = msg;
} 

// api요청 성공 응답
public ApiResponse(String data) {
	this.status = 200;
	this.data = data;
}
```

정적 팩토리 메서드는 이름을 가질 수 있기 때문에 부가적인 정보를 얻을 수 있다. **한 클래스에 시그니처가 같은 생성자가 여러 개 필요할 것 같다면 정적 팩터리 메서드로 바꾸고 각각의 차이를 잘 드러내도록 이름을 지어주자.**

```java
ApiResponse.fail("부정확한 요청입니다");
ApiResponse.success("{\"price\":10000}");
```



### 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다. (캐싱)

public 생성자의 경우 항상 힙메모리에 새로운 객체를 만들게 되어있다. 따라서 생성자를 호출하는 것은 캐시된 인스턴스를 반환할 수 없음을 의미한다. 

```java
new Integer(1); // 라이브러리를 까보면(?) 새롭게 메모리를 할당하는 것이라고 설명이 되어있다.
```

정적 팩토리 메서드를 적절히 사용하게 되면 인스턴스를 미리 만들어 놓거나, 생성된 인스턴스를 캐싱하여 재활용함으로써 불필요한 객체 생성을 피할 수 있다. 특히 **생성 비용이 큰 객체의 경우에는 더욱 효과를 발휘할 수 있다**. 

```java
Integer.valueOf(1); // 기존에 미리 만들어놓은 Integer 객체를 리턴한다.
```



### 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.  (다형성)

public 생성자는 항상 동일한 유형의 객체만 반환가능하며 자신의 서브타입 객체를 리턴할 수 없다. 하지만 정적 팩토리 메서드를 이용하면 자신의 서브타입도 반환해줄 수 있다. 

```java
class Item {
  public static Item createGun(){return new Gun();}
  public static Sword createSword(){return new Sword();}
}

Item.createGun();
Item.createSword();
```

**구현 클래스를 공개하지 않으면서도 원하는 타입의 하위 타입의 클래스를 자유롭게 가져올 수 있다**. 예를들면 자바의 컬렉션 프레임워크는 수정 불가나 동기화 등의 기능을 덧붙인 45개의 구현체를 공개하지 않고 Collectors를 이용하여 생성할 수 있도록 설계했는데 이 때문에 API 외견을 더 심플하게 만들 수 있었다. 

또한 매개변수를 읽어들여 적절하게 서브타입을 반환할 수 있다는 장점도 같이 따라오게 되는데 이를 잘 사용하면 coupling을 줄일수도 있다.

```java
public static Item random(int random) {
  if(random % 2 == 1) {
    return Gun();
  } else {
    return Sword();
  }
}

Item.random(random());
```



### 단점 1 : 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.

**상속을 하려면 public이나 protected같은 생성자가 필요**한데 이러한 생성자 없이 오로지 정적 펙터리 메서드만 제공한다면 상속을 통해 하위 타입을 만들 수 없다.

### 단점 2 : 정적 펙터리 메서드는 프로그래머가 찾기 어렵다.

위를 예시로 들면 누군가가 내 Item 클래스를 사용을 하려고 하는데 createGun()이 있는지 없는지 클래스를 직접 까보지 않는 이상은 알 수 없을것이다. 따라서 **정적 펙터리 메서드에 대한 설명이 명확하지 않기 때문에 사용자가 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야 한다**. 이러한 단점을 보완하기 위한 방법으로 API 문서를 잘 작성해놓거나 널리 알려진 정적 팩터리 메서드 이름을 따라 짓는 방법이 있다.

```java
// from : 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
Date d = Date.from(xxx);

// of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);

// instance, getInstance : 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다.

// create, newInstance : instance, getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
Array.newInstance(classObject, arrayLen);

// getXXX , newXXX: getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.
FileStore fs = Files.getFileStore(path);
```



## 아이템 02: 생성자에 매개변수가 많다면 빌더를 고려하라.

정적 팩터리, public 생성자는 선택적 매개변수가 많을 때 굉장히 복잡해진다. 기존에는 이러한 선택적 매개변수가 많을 때는 점층적 생성자 패턴을 사용해왔다.



### 점층적 생성자 패턴

```java
public Member(Long id, String name, int age, Sex sex, boolean isMembership, ....) {...}
public Member(Long id, int age, Sex sex, boolean isMembership, ....) { this(id, "", sex, isMemeberShip..)}
public Member(Long id, String name, int age, boolean isMembership, ....) { this(id, name, age, Sex.01, is..)}
public Member(Long id, boolean isMembership, ....) {...}
```

이렇게 다양한 매개변수가 존재하는 생성자를 사용하는 것은 많은 불편함이 있다.

1. 생성자를 계속 추가해주어야 한다. (기존에 생성되어있는 패턴을 오묘하게 잘 피해서..)
2. 매개변수의 순서와 의미를 알아야 한다. (ex. new Order("살코기",100,2,3000,2,"옵션1"); )
3. 리팩토링이 어렵다. 단순하게 매개변수의 위치를 바꾼다고 했을 때 사용하는 모든 코드를 수정해주어야 한다. 심지어 바꾼 매개변수들의 타입이 같다면 컴파일 에러도 안뱉어서 잡지 못한다.

### 자바빈즈 패턴

디폴트 생성자로 객체를 만들고 세터 메서드들을 호출하여 매개변수를 세팅하는 방식이다.

```java
public class Order {
  private int id;
  private String name;
  public void setId(int id){this.id = id;}
  public void setName(String name){this.name = name;}
}

{
  Order order = new Order();
  order.setId(1);
  order.setName("주문1");
}
```

위와 같은 자바빈즈 패턴으로 위의 문제들을 해결할수는 있다만 아래와 같은 문제들이 발생할 수 있다.

1. 생성하기 위한 코드가 길어졌다.
2. 객체가 완전히 생성되기 전까지는 일관성이 없을 수 있다. 
    - 생성자를 이용해서 객체를 생성하면 한번에 모든 인자를 다 받기 때문에 각각 인자들의 일관성을 체크해볼수있음
3. 객체에 지속적으로 값을 세팅해줘야하므로 불변객체로 만들수도 없다.



### 빌더 패턴

클래스를 만들기 위한 빌더를 만들고 빌더가 제공하는 세터 메서드들을 체이닝 형식으로 호출하여 원하는 인스턴스를 생성할 수 있다.

```java
public class Order {
  private int id;
  private String name;
  private int price;
  private int calories;

  public static class OrderBuilder {
    private int id;
    private String name;
    private int price;
    private int calories;
    
    public OrderBuilder id(int id) {this.id = id;}
    public OrderBuilder name(String name) {this.name = name;}
   	...
    public Order build() {
      Order order = new Order();
      order.id = id;
      ...
    }  
  }
}

{
  Order order = Order.OrderBuilder().id(1).name("주문1").price(1000).build();
}
```

빌더 패턴의 단점이 있다면 너무 장황한 코드들이 필요하다는 것이다. 사용하는 입장에서는 편리해졌지만 제공하는 입장에서는 수고스러움이 많다. 아이템 2의 주제가 매개변수가 많아지는 것을 고려하면 빌더패턴을 만들라고 했으니 반대로 매개변수가 적은데 빌더패턴을 사용하려한다면 배보다 배꼽이 큰 경우가 올수도 있다는 점도 알아두자.

> Lombok 프로젝트의 @Builder 패턴은 이러한 수고를 덜어줄 수 있다.





## 아이템 03: private 생성자나 열거 타입으로 싱글턴임을 보증하라

싱글턴 : 오직 인스턴스를 하나만 생성할 수 있는 클래스

클래스를 싱글턴으로 만듦으로 무상태 객체나 설계상 유일해야 하는 시스템 컴포넌트로 만든다.



### 싱글턴 만드는 방법 1

private 생성자를 만들고, static 필드를 이용해 접근하게 만든다.

```java
// 방법 1
public class Singleton {
    public static final Singleton singleton = new Singleton();
    
    private Singleton() { ... } 
    
    
}
```

위의 예시 코드의 경우를 봤을 때는 private 생성자는 Singleton 클래스가 초기화될 때 딱한번 호출될거라 생각된다. 하지만 리플렉션 API를 사용한다면 private 생성자는 다시 호출 가능하다. 따라서 위와같은 방식으로 싱글턴을 만들고자 한다면 생성자 내부에 두 번째 객체가 생성되려 할 때 예외를 던지도록 수정을 해야 한다. 

또한 해당 클래스가 직렬화가 가능하다면 이것또한 또 다른 인스턴스를 만들게 될 수도 있다. 따라서 모든 인스턴스 필드를 transient라 선언하고 readResolve 와 같은 메서드를 제공해야 한다.

```java
private Singleton() {
  if(Singleton.singleton != null) {
    throw IllegalAccessException("this class shoud be singleton");
  }
}
```

### 싱글턴 만드는 방법 2

정적 팩터리 메서드를 static 으로 만들어 제공한다.

```java
public class Singleton {
  private static final Singleton instance = new Singleton();
  private Singleton(){...}
  public static Singleton getInstance() { return instance; }
}
```

위의 예제 또한 1번 방법과 같이 리플렉션 및 직렬화에 취약하다. 다만 위의 방법이 가져올 수 있는 장점은 다음과 같다

1. API를 바꾸지 않고도 싱글턴이 아니게 변경 할 수 있다

2. 원한다면 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다

### 싱글턴을 만드는 방법 3

```java
public enum Singleton {
  INSTANCE;
  
  private Singleton(){}
}
```

위의 방법이 책에서 추천하는 방법인데 방법 2정도까지만 만들어두면 괜찮을 것 같다.



## 아이템 04: 인스턴스화를 막으려거든 private 생성자를 사용하라

정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 것이 아니다. 하지만 이러한 클래스들은 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 생성해놓는다. 이처럼 의도치 않게 인스턴스화할 수 있게 된 클래스가 종종 목격된다. 

그러면 abstract class를 이용해서 인스턴스화 하는걸 막을 수 있지 않을까?? 이러한 생각도 아쉽게도 인스턴스화를 막을 수 있는 방법은 아니다. 왜냐하면 해당 추상클래스를 상속받아 정의하는 하위클래스를 만들어 인스턴스화할 수 있기 때문이다. 또한 abstract class를 보면 왠지 모르게 하위 클래스를  만들어서 쓰라고 하는 것 같아보이니 더 큰 문제다. 

결론적으로는 이러한 생성자를 인스턴스화 하는걸 막기위해서는 private 생성자를 선언해주어야 한다. 이렇게 한다면 컴파일러가 생성자가 있으니 자동으로 생성자를 추가해놓지도, 이를 상속받아서 사용할수도, 직접 생성해서 사용할수도 없기 때문이다. 

또한 private 생성자 내부에 호출이 되면 에러를 내뱉도록 추가해주어도 좋을것이다. 왜냐하면 리플렉션이나 직렬화도중에 생성이 될수도 있으니까..

한가지 유의하면 좋을 점은 이러한 private 생성자는 개발자가 볼때 직관적이게 보일수가 없다. 왜냐하면 생성자를 만들어놓고 사용하지 못하게 private으로 선언해놓다니 이게 뭔가 ?? 할수도 있기 때문이다. 따라서 이와 같은 코드에는 적절한 주석을 추가해 주는게 좋다.



------정리중------